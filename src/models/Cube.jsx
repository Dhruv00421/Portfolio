// /*
// Auto-generated by: https://github.com/pmndrs/gltfjsx
// */

import * as THREE from 'three'
import React, { useRef, useEffect, useState } from 'react'
import { useFrame, useThree } from '@react-three/fiber'
import { useGLTF, useAnimations, Plane } from '@react-three/drei'
import { a, useSpring } from '@react-spring/three'
// import { GLTF } from 'three-stdlib'

const cubeModel = '/3DModels/Cube_Model.glb';


const Cube = ({
  isRotating, 
  setIsRotating, 
  currentStage,
  setCurrentStage,
  onSwipeOffset,
  ...props
}) => {
  const cubeRef = useRef()
  const groupRef = useRef()
  
  const {gl, viewport} = useThree();
  
  const { nodes, materials, animations } = useGLTF(cubeModel)
  const { actions } = useAnimations(animations, cubeRef)

  const lastX = useRef(0);
  const rotationSpeed = useRef(0);
  const dampingFactor = 0.95;

  const handlePointerDown = (e) => {
    e.stopPropagation();
    e.preventDefault();
    setIsRotating(true);

    const clientX = e.touches ? e.touches[0].clientX : e.clientX;

    lastX.current = clientX;
  }
  const handlePointerUp = (e) => {
    e.stopPropagation();
    e.preventDefault();
    setIsRotating(false);
    rotationSpeed.current = 0;
    
  }

  useEffect(() => {
    const canvas = gl.domElement;
    const handlePointerLeave = () => setIsRotating(false);

    canvas.addEventListener('pointerleave', handlePointerLeave);

    return () => {
      canvas.removeEventListener('pointerleave', handlePointerLeave);
    };
}, [gl]);

  const handlePointerMove = (e) => {
  e.stopPropagation();
  e.preventDefault();

  if (isRotating) {
    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
    const deltaX = (clientX - lastX.current) / viewport.width;

    // Changed from cubeRef to groupRef to rotate the whole group
    groupRef.current.rotation.y += deltaX * 0.01 * Math.PI;
    lastX.current = clientX;
    rotationSpeed.current = deltaX * 0.01;

    // Move this inside the isRotating check and use the deltaX calculated above
    if (onSwipeOffset) {
      const maxVerticalShift = 20; // max pixels HomeInfo will move up/down
      const verticalOffset = Math.max(Math.min(-deltaX * maxVerticalShift * 10, maxVerticalShift), -maxVerticalShift);
      onSwipeOffset(verticalOffset);
    }
  }
}

  const handleKeyDown = (e) => {
    if (e.key === 'ArrowLeft') {
      if(!isRotating) setIsRotating(true);
      // Changed from cubeRef to groupRef to rotate the whole group
      groupRef.current.rotation.y += 0.01 * Math.PI;

    }else if(e.key === 'ArrowRight') {
      if(!isRotating) setIsRotating(true);
      // Changed from cubeRef to groupRef to rotate the whole group
      groupRef.current.rotation.y -= 0.01 * Math.PI;
    }
  }

  const handleKeyUp = (e) => {
    if (e.key === 'ArrowLeft' || e.key === 'ArrowRight') {
      setIsRotating(false);
    }
  }

  useFrame(() => {
    if (!isRotating) {
      rotationSpeed.current *= dampingFactor;

      if (Math.abs(rotationSpeed.current) < 0.001) {
        rotationSpeed.current = 0;
      }

      // Changed from cubeRef to groupRef to rotate the whole group
      groupRef.current.rotation.y += rotationSpeed.current;
    } else {
      // Changed from cubeRef to groupRef for stage detection
      const rotation = groupRef.current.rotation.y;
      const normalizedRotation = ((rotation % (2 * Math.PI)) + 2 * Math.PI) % (2 * Math.PI);

      switch (true) {
        case normalizedRotation >= 5.45 && normalizedRotation <= 5.85:
          setCurrentStage(4);
          break;
        case normalizedRotation >= 0.85 && normalizedRotation <= 1.3:
          setCurrentStage(3);
          break;
        case normalizedRotation >= 2.4 && normalizedRotation <= 2.6:
          setCurrentStage(2);
          break;
        case normalizedRotation >= 4.25 && normalizedRotation <= 4.75:
          setCurrentStage(1);
          break;
        default:
          setCurrentStage(null);
      }
    }
    
    // Keep the cube hover animation (this still affects only the cube)
    const t = performance.now() / 1000;
    const hoverHeight = 0.1; // controls the amplitude of the hover
    const baseY = 0;     // original Y position of the cube 1.183

    if (cubeRef.current) {
      cubeRef.current.position.y = 1.183 + (Math.sin(t * 2) + 1) * (hoverHeight / 2);
    }
  });

  useEffect(() => {
    const canvas = gl.domElement;
    canvas.addEventListener('pointerdown', handlePointerDown);
    canvas.addEventListener('pointerup', handlePointerUp);
    canvas.addEventListener('pointermove', handlePointerMove);
    document.addEventListener('keydown', handleKeyDown); 
    document.addEventListener('keyup', handleKeyUp);

    return () => {
      canvas.removeEventListener('pointerdown', handlePointerDown);
      canvas.removeEventListener('pointerup', handlePointerUp);
      canvas.removeEventListener('pointermove', handlePointerMove);
      document.removeEventListener('keydown', handleKeyDown);
      document.removeEventListener('keyup', handleKeyUp);
    }
  }, [gl, handlePointerDown, handlePointerUp, handlePointerMove]);
  
  return (
    <a.group ref={groupRef} {...props}>
      <group name="Scene">
        <mesh
          name="Torus"
          castShadow
          receiveShadow
          geometry={nodes.Torus.geometry}
          material={materials.Stand}
          // position={[1.556, 0.098, 2.546]}
          position={[0, 0.098, 0]}
          scale={[0.125, 0.189, 0.125]}
        />
        <mesh
          name="Torus001"
          castShadow
          receiveShadow
          geometry={nodes.Torus001.geometry}
          material={materials.Stand}
          // position={[1.556, 0.089, 2.546]}\
          position={[0, 0.089, 0]}
          scale={[0.1, 0.087, 0.1]}
        />
        <a.mesh
          ref={cubeRef}
          name="Cube001"
          castShadow
          receiveShadow
          geometry={nodes.Cube001.geometry}
          // material={materials.Cube}
          // position={[1.555, 1.183, 2.542]}
          position={[-0.001, 1.183, -0.004]}
          rotation={[-0.699, 0.426, -0.457]}
        >
          <meshPhysicalMaterial
            color="#63B3ED"
            metalness={1}
            roughness={0.1}
            transmission={0.9}
            thickness={0.5}
            emissive="#63B3ED"
            emissiveIntensity={1}
            clearcoat={1}
            clearcoatRoughness={0}
          />
        </a.mesh>
        <group name="Cylinder001" position={[0, 0.074, 0]} > // position={[1.556, 0.074, 2.546]}
          <mesh
            name="Cylinder001_1"
            castShadow
            receiveShadow
            geometry={nodes.Cylinder001_1.geometry}
            
            material={materials.Material}
          >
            <meshPhysicalMaterial
              color="#1A202C"
              metalness={1}
              roughness={0.1}
              clearcoat={1}
              clearcoatRoughness={0}
            />
          </mesh>
          <mesh
            name="Cylinder001_2"
            castShadow
            receiveShadow
            geometry={nodes.Cylinder001_2.geometry}
            material={materials.Glow}
          >
            <meshPhysicalMaterial
              color= "#1A202C"
              metalness={1}
              roughness={0.1}
              emissive="#1A202C"
              emissiveIntensity={1}
              clearcoat={1}
              clearcoatRoughness={0}
            />
          </mesh>
        </group>
      </group>
    </a.group>
  )
}

export default Cube;
